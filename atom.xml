<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tomzhu0225.github.io</id>
    <title>FUSION!</title>
    <updated>2021-06-08T07:59:30.517Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tomzhu0225.github.io"/>
    <link rel="self" href="https://tomzhu0225.github.io/atom.xml"/>
    <subtitle>我叫朱博文，一个有奇思妙想的学生</subtitle>
    <logo>https://tomzhu0225.github.io/images/avatar.png</logo>
    <icon>https://tomzhu0225.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, FUSION!</rights>
    <entry>
        <title type="html"><![CDATA[椭圆形船过水道问题]]></title>
        <id>https://tomzhu0225.github.io/post/tuo-yuan-xing-chuan-guo-shui-dao-wen-ti/</id>
        <link href="https://tomzhu0225.github.io/post/tuo-yuan-xing-chuan-guo-shui-dao-wen-ti/">
        </link>
        <updated>2021-06-08T07:50:00.000Z</updated>
        <summary type="html"><![CDATA[<p>本文使用CC-BY-SA-3.0协议，意味着：署名，相同方式共享，不设额外限制</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文使用CC-BY-SA-3.0协议，意味着：署名，相同方式共享，不设额外限制</p>
<!-- more -->
<p><img src="https://tomzhu0225.github.io/post-images/1623138741269.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138635560.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138644296.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138652261.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138660950.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138673941.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138681855.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138689931.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138702363.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138716853.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1623138725355.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用示波器显示图片（视频）]]></title>
        <id>https://tomzhu0225.github.io/post/shi-yong-shi-bo-qi-xian-shi-tu-pian-shi-pin/</id>
        <link href="https://tomzhu0225.github.io/post/shi-yong-shi-bo-qi-xian-shi-tu-pian-shi-pin/">
        </link>
        <updated>2021-05-07T10:46:44.000Z</updated>
        <summary type="html"><![CDATA[<p>本论文本为物理实验改进的作业。本实验的想法源于自己的一些个人兴趣，是一直想做的事情，很多人已经使用了专业的信号生成器实现了在示波器上绘画图像，但是还没有人使用音频接口（3.5mm耳机接口）来生成图像，这次实验是对耳机（音频）产生原理的一次出色实践。由此产生了利用耳机接口来生成信号的想法。前几日完成了该项实验的基本任务，但是距离发表还有一段距离。自行购买了虚拟示波器，将在电脑上对该项实验进行更加详尽的测试，对示波器和音频使用何种参数可以得到最佳的图像进行探究。事实上要探究这种问题，实际上就是探索hyperparameter的取值，从原理来说完全可以使用梯度下降法对hyperparameter进行探究，我们只需要确定一个对示波器成像质量进行衡量的矩阵。注意本文使用MIT licence。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本论文本为物理实验改进的作业。本实验的想法源于自己的一些个人兴趣，是一直想做的事情，很多人已经使用了专业的信号生成器实现了在示波器上绘画图像，但是还没有人使用音频接口（3.5mm耳机接口）来生成图像，这次实验是对耳机（音频）产生原理的一次出色实践。由此产生了利用耳机接口来生成信号的想法。前几日完成了该项实验的基本任务，但是距离发表还有一段距离。自行购买了虚拟示波器，将在电脑上对该项实验进行更加详尽的测试，对示波器和音频使用何种参数可以得到最佳的图像进行探究。事实上要探究这种问题，实际上就是探索hyperparameter的取值，从原理来说完全可以使用梯度下降法对hyperparameter进行探究，我们只需要确定一个对示波器成像质量进行衡量的矩阵。注意本文使用MIT licence。</p>
<!-- more -->
<p><img src="https://tomzhu0225.github.io/post-images/1620994487352.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994493096.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994498968.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994503426.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994507386.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994511598.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994515826.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994521167.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994525875.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994530696.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994535502.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994541212.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1620994547429.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[画图软件使用指南&画图软件python代码]]></title>
        <id>https://tomzhu0225.github.io/post/hua-tu-ruan-jian-shi-yong-zhi-nan/</id>
        <link href="https://tomzhu0225.github.io/post/hua-tu-ruan-jian-shi-yong-zhi-nan/">
        </link>
        <updated>2021-04-02T09:50:29.000Z</updated>
        <summary type="html"><![CDATA[<p>将我的代码的一些冗余部分进行了删减。要正常运行该代码，首先需要pip本代码使用的库，或者直接下载anaconda的环境；其次主菜单启动图片的加载是载入记录在另一个py文件中的图片的base64编码的，若直接复制代码运行会出错，若要运行请将‘from memory_pic import *’删除，将get_pic函数删除并修改‘a=random.randint(1,3)<br>
name=&quot;bizhi&quot;+str(a)+'_gif'<br>
filename=&quot;bizhi&quot;+str(a)+'.gif'<br>
get_pic(eval(name), filename)<br>
photo = tk.PhotoImage(file=filename)’换成您的图片的绝对地址（只能是gif图片），</p>
]]></summary>
        <content type="html"><![CDATA[<p>将我的代码的一些冗余部分进行了删减。要正常运行该代码，首先需要pip本代码使用的库，或者直接下载anaconda的环境；其次主菜单启动图片的加载是载入记录在另一个py文件中的图片的base64编码的，若直接复制代码运行会出错，若要运行请将‘from memory_pic import *’删除，将get_pic函数删除并修改‘a=random.randint(1,3)<br>
name=&quot;bizhi&quot;+str(a)+'_gif'<br>
filename=&quot;bizhi&quot;+str(a)+'.gif'<br>
get_pic(eval(name), filename)<br>
photo = tk.PhotoImage(file=filename)’换成您的图片的绝对地址（只能是gif图片），</p>
<!-- more -->
<h1 id="软件主界面">软件主界面</h1>
<figure data-type="image" tabindex="1"><img src="https://tomzhu0225.github.io/post-images/1617357086090.jpg" alt="软件主界面" loading="lazy"></figure>
<pre><code class="language-markdown">画图软件运行后会出现该主界面。主界面的左上角是三枚菜单按键，其中设置菜单键，可设置画布的快捷键（该功能正在开发中）；单击帮助键，软件将打开浏览器跳转到该使用指南。
</code></pre>
<h2 id="画图键">画图键</h2>
<pre><code class="language-markdown">将鼠标移至画图键，出现下拉菜单，保存按键功能正在开发中。单击新画板，来新建画布。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://tomzhu0225.github.io/post-images/1617357119924.png" alt="画图键菜单" loading="lazy"></figure>
<pre><code class="language-markdown">单击新画板后系统出现弹窗。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tomzhu0225.github.io/post-images/1617357153165.png" alt="画布设置弹窗" loading="lazy"></figure>
<pre><code class="language-markdown">在画布长度一栏中输入整数，设置画布x轴长度；同理在画布高度一栏中输入整数，设置画布y轴长度。该项数据默认为（1920，1080）
单击选择画布颜色键选择画布的背景颜色，此时系统会弹出系统默认的颜色选择框。若不进行选择，系统默认画布颜色为黑色。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://tomzhu0225.github.io/post-images/1617357178256.png" alt="颜色选择框" loading="lazy"></figure>
<pre><code class="language-markdown">点击画布设置框中的新建画布即可创建画布
</code></pre>
<h1 id="画布界面">画布界面</h1>
<figure data-type="image" tabindex="5"><img src="https://tomzhu0225.github.io/post-images/1617357193085.png" alt="画布界面" loading="lazy"></figure>
<pre><code class="language-markdown">画布界面分为两个部分：浮动的工具栏和画布主体。
** 须知工具栏总在窗口的最前端，且一但关闭只能重新新建画布 **
</code></pre>
<h2 id="工具栏">工具栏</h2>
<h3 id="常规工具">常规工具</h3>
<pre><code class="language-markdown">对于画笔、矩形、椭圆（圆）、橡皮擦、直线、箭头直线工具，使用方法类似。在画布窗口点击鼠标左键并且不抬起，在画布窗口中滑动进行绘画，抬起鼠标左键绘画终止。
</code></pre>
<h3 id="新建文本">新建文本</h3>
<pre><code class="language-markdown">单击新建文本后，弹出对话框，输入想打印的文本，单击确认。
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://tomzhu0225.github.io/post-images/1617357219070.png" alt="输入文本" loading="lazy"></figure>
<pre><code class="language-markdown">后在画布界面，您想要插入文本的地方单击一次，并在画布的另一个位置单击另一次，插入文本的大小将根据两次单击的x轴距离进行相应计算，插入文本的中心与两次单击的连线中点的位置重合。
</code></pre>
<h3 id="插入图片">插入图片</h3>
<figure data-type="image" tabindex="7"><img src="https://tomzhu0225.github.io/post-images/1617357242639.png" alt="文件选择对话框" loading="lazy"></figure>
<pre><code class="language-markdown">单击插入图片，弹出系统文件选择框，支持高达4种的图片文件格式，选择图片文件后，系统弹出对话框
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://tomzhu0225.github.io/post-images/1617357261046.png" alt="图片比例" loading="lazy"></figure>
<pre><code class="language-markdown">选择想要的图片比例后，单击插入图片后在画布上单击，单击位置即为图片插入的中心位置。
</code></pre>
<h3 id="颜色">颜色</h3>
<pre><code class="language-markdown">单击颜色文件选择颜色，该选项可以控制画笔、矩形、椭圆（圆）、直线、箭头直线、新建文本以及填充的颜色。默认画笔颜色为黄色。
</code></pre>
<h3 id="清屏">清屏</h3>
<pre><code class="language-markdown">删除画布上一切内容
</code></pre>
<h3 id="右侧粗细选择滑动条">右侧粗细选择滑动条</h3>
<pre><code class="language-markdown">该选项可以控制画笔、矩形、椭圆（圆）、直线、橡皮擦、箭头直线的粗细。系统默认值为5。
</code></pre>
<h3 id="选择">选择</h3>
<pre><code class="language-markdown">单击选择按钮后，单击鼠标左键并且拖动，进行框选，框选完成后松开鼠标左键，按住鼠标右键进行拖动改变选中内容的位置。
</code></pre>
<h3 id="填充">填充</h3>
<pre><code class="language-markdown">在画板上有用**画笔**工具**一笔画出**的**闭合曲线**时，点击填充，在待填充曲线的内部，单击鼠标左键并等待，在填充颜色出现前不要移动鼠标。
</code></pre>
<pre><code class="language-markdown">注意：在填充前缩放画布可能会导致未知bug；在填充后，选择并移动被填充部位或者是缩放画布可能会异常卡顿
</code></pre>
<h2 id="常用快捷键其他操作">常用快捷键&amp;其他操作</h2>
<h3 id="缩放画布">缩放画布</h3>
<pre><code class="language-markdown">鼠标滚轮滚动
</code></pre>
<h3 id="撤销操作">撤销操作</h3>
<pre><code class="language-markdown">键盘快捷键：CTRL＋Z
</code></pre>
<h3 id="平移画布">平移画布</h3>
<pre><code class="language-markdown">在画布下侧和右侧分别有滚动条，当放大画布时，滚动条会出现滑块，此时可以进行画布的平移。
</code></pre>
<h3 id="画笔颜色快捷键">画笔颜色快捷键</h3>
<pre><code class="language-markdown">键盘按键：ｒ　转换画笔颜色为红色。
键盘按键：ｇ　转换画笔颜色为绿色。
键盘按键：ｂ　转换画笔颜色为蓝色。
键盘按键：ｙ　转换画笔颜色为黄色。
</code></pre>
<pre><code>
import tkinter as tk
from tkinter import messagebox
from tkinter.colorchooser import askcolor
from tkinter import *
import random
from memory_pic import *
from base64 import * 
import ctypes
import tkinter.filedialog
from tkinter.ttk import *
from os.path import exists
import PIL.Image
import os, sys
import numpy as np
import math
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

import webbrowser
#创建窗口，root可替换成自己定义的窗口
sys.setrecursionlimit(1000000) #重新设置栈空间
root = tk.Tk()
#调用api设置成由应用程序缩放
ctypes.windll.shcore.SetProcessDpiAwareness(1)
#调用api获得当前的缩放因子
ScaleFactor=ctypes.windll.shcore.GetScaleFactorForDevice(0)
#设置缩放因子
root.tk.call('tk', 'scaling', ScaleFactor/75)

col_1=(0,'#000000')
width_b=0
height_b=0
global i #对于插入文本功能的全局计数器
i=0

win_width = 1000* ScaleFactor/100
win_height = 500 * ScaleFactor/100

class Application(Frame):
    &quot;&quot;&quot;一个经典的GUI写法&quot;&quot;&quot;

    def __init__(self, master=None):
        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;
        super().__init__(master)  # 调用父类的初始化方法
        self.x = 0
        self.y = 0
        self.fgcolor = 'yellow'
        self.lastdraw = 0
        self.start_flag = False
        self.master = master
        self.pack()
        self.createWidget()
        self.Tbar()
        self.start_flag_text= True
        self.thickness=5
        self.stlist=[]
        self.w=None
        self.start_flag_pic=True
        self.start_fill=True
        self.coordsrect=[]
        self.chosenlist=[]
        self.j=0
        self.penmarklist=[]
        self.pencount=0
        self.pencountflag=False

    def createWidget(self):
        &quot;&quot;&quot;创建画图区域&quot;&quot;&quot;
        self.drawpad = tk.Canvas(self, width=width_b, height=height_b, bg=col_1[1])
        self.drawpad.grid()
        self.drawpad.bind('&lt;ButtonRelease-1&gt;', self.stopDraw)  
        
        # 创建按钮
        self.xsb = tk.Scrollbar(self, orient=&quot;horizontal&quot;, command=self.drawpad.xview)
        self.ysb = tk.Scrollbar(self, orient=&quot;vertical&quot;, command=self.drawpad.yview)
        self.drawpad.configure(yscrollcommand=self.ysb.set, xscrollcommand=self.xsb.set)
        self.drawpad.configure(scrollregion=(0,0,1000,1000))
        # draw
        
        self.layout()
        # This is what enables scrolling with the mouse:
        self.drawpad.bind(&quot;&lt;ButtonPress-1&gt;&quot;, self.scroll_start)
        self.drawpad.bind(&quot;&lt;B1-Motion&gt;&quot;, self.scroll_move)
        self.drawpad.bind(&quot;&lt;B3-Motion&gt;&quot;, self.movethechosen)
        #windows scroll
        self.drawpad.bind(&quot;&lt;MouseWheel&gt;&quot;,self.zoomer)
    
    def tocanvasxy(self, event):
        return int(self.drawpad.canvasx(event.x)), int(self.drawpad.canvasy(event.y))
        
    def scroll_start(self, event):
        x, y = self.tocanvasxy(event)
        self.drawpad.scan_mark(x, y)

    def scroll_move(self, event):
        x, y = self.tocanvasxy(event)
        self.drawpad.scan_dragto(x, y, gain=1)
        

    def zoomer(self, event):
        x, y = self.tocanvasxy(event)
        if (event.delta &gt; 0):
            self.drawpad.scale(&quot;all&quot;, x, y, 1.1, 1.1)
        elif (event.delta &lt; 0):
            self.drawpad.scale(&quot;all&quot;, x, y, 0.9, 0.9)
        self.drawpad.configure(scrollregion = self.drawpad.bbox(&quot;all&quot;))
    
    
    def layout(self):
        self.xsb.grid(row=1, column=0, sticky=&quot;ew&quot;)
        self.ysb.grid(row=0, column=1, sticky=&quot;ns&quot;)
        self.drawpad.grid(row=0, column=0, sticky=&quot;nsew&quot;)
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        
    def scroll_start(self, event):
        self.drawpad.scan_mark(event.x, event.y)

    def scroll_move(self, event):
        self.drawpad.scan_dragto(event.x, event.y, gain=1)
    
    
    
    def cancel_1(self):
        self.quest_1.destroy()    
    def cancel_2(self):
        self.quest_2.destroy()  
    #创建悬浮工具窗
    def confirm_1(self):
        
        self.text = self.text_w.get()
        self.start_flag_text= True            
        
        self.quest_1.destroy()
        #画板外框宽
    def confirm_2(self):
        
        
                  
        
        self.quest_2.destroy()    
        self.start_flag_pic=True
    def Tbar(self):
        def thicknessslider(v):
            self.thickness = v
        self.tbar=tk.Tk()
        
        
        self.menubar=Frame(self.tbar)
        #self.tbar.overrideredirect(True)
        self.tbar.attributes(&quot;-topmost&quot;, True)
        self.tbar.attributes(&quot;-toolwindow&quot;, 1)
        self.menubar.pack()
        
        self.slider = tk.Scale(self.tbar, label='粗细', from_=0, to=100, orient=tk.VERTICAL, length=500, showvalue=1,tickinterval=2, resolution=1, command=thicknessslider)
        self.slider.pack(side='right')

        self.btn_start = Button(self.tbar, name='start', text='开始')
        self.btn_start.pack(side='top', pady=10,ipadx=20)
        self.btn_pen = Button(self.tbar, name='pen', text='画笔')
        self.btn_pen.pack(side='top', pady=10,ipadx=20)
        self.btn_rect = Button(self.tbar, name='rect', text='矩形')
        self.btn_rect.pack(side='top', pady=10,ipadx=20)
        self.btn_oval = Button(self.tbar, name='oval', text='椭圆')
        self.btn_oval.pack(side='top', pady=10,ipadx=20)
        self.btn_circle = Button(self.tbar, name='circle', text='圆')
        self.btn_circle.pack(side='top', pady=10,ipadx=20)
        self.btn_clear = Button(self.tbar, name='clear', text='清屏')
        self.btn_clear.pack(side='top', pady=10,ipadx=20)
        self.btn_erasor = Button(self.tbar, name='erasor', text='橡皮擦')
        self.btn_erasor.pack(side='top', pady=10,ipadx=20)
        self.btn_line = Button(self.tbar, name='line', text='直线')
        self.btn_line.pack(side='top', pady=10,ipadx=20)
        self.btn_line_arrow = Button(self.tbar, name='line_arrow', text='箭头直线')
        self.btn_line_arrow.pack(side='top', pady=10,ipadx=20)
        self.btn_color = Button(self.tbar, name='color', text='颜色')
        self.btn_color.pack(side='top', pady=10,ipadx=20)
        self.btn_text=Button(self.tbar,name='text',text='新建文本')
        self.btn_text.pack(side='top',pady=10,ipadx=20)
        self.btn_pic=Button(self.tbar,name='pic',text='插入图片')
        self.btn_pic.pack(side='top',pady=10,ipadx=20)
        self.btn_cho=Button(self.tbar,name='choose',text='选择')
        self.btn_cho.pack(side='top',pady=10,ipadx=20)
        self.btn_fill=Button(self.tbar,name='fill',text='填充')
        self.btn_fill.pack(side='top',pady=10,ipadx=20)
        # 绑定事件
        self.btn_line.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_line_arrow.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_rect.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_oval.bind('&lt;Button-1&gt;', self.eventManager)
        self.btn_circle.bind('&lt;Button-1&gt;', self.eventManager)
        self.btn_pen.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_erasor.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_clear.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_color.bind('&lt;Button-1&gt;', self.eventManager)  # 点击按钮事件
        self.btn_cho.bind('&lt;Button-1&gt;', self.eventManager)
        self.btn_fill.bind('&lt;Button-1&gt;', self.eventManager)
        self.master.bind('&lt;KeyPress-r&gt;', self.hotKey)  # 绑定快捷键
        self.master.bind('&lt;KeyPress-g&gt;', self.hotKey)  # 绑定快捷键
        self.master.bind('&lt;KeyPress-b&gt;', self.hotKey)  # 绑定快捷键
        self.master.bind('&lt;KeyPress-y&gt;', self.hotKey)  # 绑定快捷键
        self.master.bind('&lt;Control-z&gt;', self.callback)
        self.btn_text.bind('&lt;Button-1&gt;',self.eventManager)
        self.btn_pic.bind('&lt;Button-1&gt;',self.eventManager)
        # 左键释放按钮
    
    
        
    
    def eventManager(self, event):
        name = event.widget.winfo_name()
        print(name)
        self.start_flag = True
        if name == 'line':
            # 左键拖动
            self.drawpad.bind('&lt;B1-Motion&gt;', self.myline)
            self.pencountflag=False
        elif name == 'line_arrow':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.myline_arrow)
            self.pencountflag=False
        elif name == 'rect':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.myrect)
            self.pencountflag=False
        elif name == 'oval':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.myoval)
            self.pencountflag=False
        elif name == 'circle':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.mycircle)
            self.pencountflag=False
        elif name == 'pen':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.mypen)
            self.pencountflag=True
        elif name == 'erasor':
            self.drawpad.bind('&lt;B1-Motion&gt;', self.myerasor)
            self.pencountflag=False
        elif name == 'clear':
            self.drawpad.delete('all')
            self.penmarklist=[]
            self.pencountflag=False
            self.pencount=0
        elif name == 'text':
            self.quest_1 = tk.Toplevel()
            self.quest_1.title('请输入文本')
            self.quest_1.geometry('300x150+800+500')
            self.text_w = tk.StringVar() 
            self.text_w.set('插入文本') 
            self.pencountflag=False
            #tk.Label(quest, text='画布长度 ').place(x=20, y=20) 
    
            self.entry_text = tk.Entry(self.quest_1, textvariable=self.text_w) 
                
            self.entry_text.place(x=10, y=20)
            self.confirm = tk.Button(self.quest_1, text='确认', command=self.confirm_1)
            self.confirm.place(x=100,y=70)
            self.cancel = tk.Button(self.quest_1, text='取消', command=self.cancel_1)
            self.cancel.place(x=200,y=70)
            self.drawpad.bind('&lt;Button-1&gt;', self.createtext) 
        elif name == 'pic':
            def rat(b):
                
                self.ratio=b
                
            self.fn=tkinter.filedialog.askopenfilename(title='选择一个图片', filetypes=[('bmp文件','.bmp'),('gif文件','.gif'),('jpg文件','.jpg'),('png文件','.png')])
            self.quest_2 = tk.Toplevel()
            self.quest_2.title(&quot;插入图片大小&quot;)
            self.quest_2.geometry('400x200+800+500')
            self.scalpic=tk.Scale(self.quest_2, label='图片比例', from_=0, to=1, orient=tk.HORIZONTAL, length=320, showvalue=1,tickinterval=2, resolution=0.01, command=rat)
            self.scalpic.pack(side=&quot;top&quot;) 
            self.file_path = self.fn
            confirm = tk.Button(self.quest_2, text='插入图片', command=self.confirm_2)
            confirm.place(x=50,y=130)
            cancel = tk.Button(self.quest_2, text='取消', command=self.cancel_2)
            cancel.place(x=200,y=130)
            self.drawpad.bind('&lt;Button-1&gt;', self.putpic)  
            self.pencountflag=False
        elif name == 'color':
            c = askcolor(color=self.fgcolor, title='请选择颜色')
            print(c)  # c的值 ((128.5, 255.99609375, 0.0), '#80ff00')
            self.fgcolor = c[1]
            self.pencountflag=False
        elif name==&quot;choose&quot;:
            self.drawpad.bind('&lt;B1-Motion&gt;', self.choose_and_move)
            self.pencountflag=False
        elif  name=='fill':
            self.drawpad.bind('&lt;Button-1&gt;', self.floodfill)
            self.start_fill=True
            self.pencountflag=False
    def startDraw(self, event):
        self.drawpad.delete(self.lastdraw)
        self.coordsrect=[]
        self.x11=0
        self.y11=0

        self.j=0
        
        if self.start_flag:
            self.start_flag = False
            self.x = self.drawpad.canvasx(event.x)
            self.y = self.drawpad.canvasy(event.y)

    def stopDraw(self, event):
        self.start_flag = True
        self.lastdraw = 0
        if self.pencountflag:
            self.pencount=self.pencount+1
    def myline(self, event):
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=self.fgcolor,width=self.thickness)
        self.stack()
    def myline_arrow(self, event):
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_line(self.x, self.y,  self.drawpad.canvasx(event.x),self.drawpad.canvasy(event.y), arrow=LAST, fill=self.fgcolor,width=self.thickness)
        self.stack()
    def myrect(self, event):
        #print('f')
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_rectangle(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), outline=self.fgcolor,width=self.thickness)
        self.stack()
    def myoval(self, event):
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_oval(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), outline=self.fgcolor,width=self.thickness)
        self.stack()
    def mycircle(self, event):
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_oval(self.x, self.y, self.drawpad.canvasx(event.x), self.y+(self.drawpad.canvasx(event.x)-self.x), outline=self.fgcolor,width=self.thickness)
        self.stack()
    def mypen(self, event):
        self.startDraw(event)
        #print('self.x=', self.x, ',self.y=', self.y)
        
        self.w=self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=self.fgcolor,capstyle=&quot;round&quot;,width=self.thickness)
        self.penonly=self.w
        self.x = self.drawpad.canvasx(event.x)
        self.y = self.drawpad.canvasy(event.y)
        self.stack()
        self.stack_pen()
    def myerasor(self, event):
        self.startDraw(event)
        self.w=self.drawpad.create_line(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y), fill=col_1[1],width=self.thickness,capstyle=&quot;round&quot;)
        self.x = self.drawpad.canvasx(event.x)
        self.y = self.drawpad.canvasy(event.y)
        self.stack()
    def hotKey(self, event):
        c = event.char
        if c == 'r':
            self.fgcolor = 'red'
        elif c == 'g':
            self.fgcolor = 'green'
        elif c == 'b':
            self.fgcolor = 'blue'
        elif c == 'y':
            self.fgcolor = 'yellow'

    def createtext(self, event):
        
        if self.start_flag_text:
            
            self.startDraw(event)
            global i
            i=i+1
            print(i)
            
            if i%2==1:
                self.x1=self.x
                
                self.y1=self.y
               
            elif i%2==0:
                a=len(self.text)**(0.8)
                self.x2=self.x
                self.y2=self.y
                self.deltax=(self.x2-self.x1)**(0.9)
                self.deltay=self.y1-self.y2
                self.meanx=(self.x1+self.x2)/2
                self.meany=(self.y1+self.y2)/2
                self.size=round(self.deltax/a)
                self.w=self.drawpad.create_text(self.meanx,self.meany,text=self.text,fill=self.fgcolor,font=('Times', self.size, 'bold italic'))
                self.stack()
                self.start_flag_text=False 
    def putpic(self,event):
        if self.start_flag_pic:
            self.photo_o = PIL.Image.open(self.file_path)
            
            w=round(int(self.photo_o.width)*float(self.ratio))
            h=round(int(self.photo_o.height)*float(self.ratio))
            self.photo_o = self.photo_o.resize((w,h)) # 将图片大小转换为（width，height）200x300大小
            file_path_list=list(self.file_path)
            del file_path_list[-4:-1]
            self.fp=&quot;&quot;.join(file_path_list)+'.gif'
            print(self.fp)
            self.photo_o.save(self.fp)
            
            self.startDraw(event)
            self.x= self.drawpad.canvasx(event.x)
            self.y= self.drawpad.canvasy(event.y)
            print(self.x)
            global photo_1
            photo_1= tk.PhotoImage(file=self.fp)
            self.w=self.drawpad.create_image(self.x, self.y,image=photo_1)                   
            self.stack()
            self.start_flag_pic=False
    
       
    def choose_and_move(self,event):
        
        self.startDraw(event)
        self.lastdraw = self.drawpad.create_rectangle(self.x, self.y, self.drawpad.canvasx(event.x), self.drawpad.canvasy(event.y),dash=(3,5),outline='grey')
        self.coordsrect.append(self.drawpad.coords(self.lastdraw))
        print(self.coordsrect)
        coords_cho=self.coordsrect[-1]
        x1=coords_cho[0]
        y1=coords_cho[1]
        x2=coords_cho[2]
        y2=coords_cho[3]
            
        self.item_cho=self.drawpad.find_enclosed(x1, y1, x2, y2)
        self.stack_1()
    def movethechosen(self,event):
        for i in range(len(self.chosenlist)):
            self.drawpad.delete(self.chosenlist.pop(-1)) 
        if self.coordsrect:
            self.j=self.j+1
            if self.j%2==1:
                self.x11=self.drawpad.canvasx(event.x)
                self.y11=self.drawpad.canvasy(event.y) 
            else:
                a=len(self.item_cho)
                
                self.delx=(ScaleFactor/75)*(self.drawpad.canvasx(event.x)-self.x11)
                self.dely=(ScaleFactor/75)*(self.drawpad.canvasy(event.y)-self.y11)
                for i in range(a):
                
                    self.drawpad.move(self.item_cho[i-1],self.delx,self.dely)
                
        else:
            None
    def floodfill(self,event):
        
        self.startDraw(event)
        if self.start_fill:
            coord_pen=[]
            a=len(self.penmarklist)
            for k in range(a):
                coord_pen.append(self.drawpad.coords(self.penmarklist[k-1]))
            b=len(coord_pen)
            c=np.array(coord_pen)
            x=(c[:,0]+c[:,2])/2
            y=(c[:,1]+c[:,3])/2
            for i in range(b):
                x[i-1]=self.drawpad.canvasx(x[i-1])
                y[i-1]=self.drawpad.canvasy(y[i-1])
            self.xfill=self.drawpad.canvasx(event.x)
            self.yfill=self.drawpad.canvasy(event.y)
                 
            delx=x-self.xfill
            dely=y-self.yfill
            eps=10**(-8)
            x=np.array(x)
            y=np.array(y)
            
            
            xy=np.concatenate((x,y),axis=0)
            
            xy=xy.reshape(2,-1).T
            print(xy)
            x_avil=[]
            y_avil=[]
            center=[self.xfill,self.yfill]
            r_list=[]
            theta_list=[]
            for i in range(len(x)):
                x_1=xy[i-1,:]
                r=math.sqrt(math.pow(x_1[0]-center[0],2)+math.pow(x_1[1]-center[1],2))
                theta=math.atan2(x_1[1]-center[1],x_1[0]-center[0])/math.pi*180#转换为角度
                if theta&lt;0:
                    theta=360+theta
                r_list.append(r)
                theta_list.append(theta)
            print(theta_list)
            theta_r=np.concatenate((theta_list,r_list),axis=0)
            theta_r=theta_r.reshape(2,-1).T
            print(theta_r)
       
            num_clusters = self.pencount
            estimator = KMeans(n_clusters=num_clusters)
            estimator.fit(xy)#聚类
            label_pred = estimator.labels_ #获取聚类标签
            centroids = estimator.cluster_centers_ #获取聚类中心
            inertia = estimator.inertia_ # 获
            print(centroids)
            
            print((centroids-np.array([self.xfill, self.yfill]))**2)
            
            a=np.argsort(np.sum((centroids-np.array([self.xfill ,self.yfill]).T)**2))
            
            num=a[0]
            
            for i in range(len(x)-1):
                if label_pred[i-1]==num:
                    x_avil.append(x[i-1])
                    y_avil.append(y[i-1])                    
            print(num)
            for i in range(len(x_avil)-1):
                for k in range(len(x_avil)-1):
                    self.w=self.drawpad.create_line(x_avil[i-1], y_avil[i-1], x_avil[k-1], y_avil[k-1] , fill=self.fgcolor,width=20)
                    self.stack()
            self.start_fill= False    
            
    def stack(self):     #对于撤回功能的栈
        if self.w == None: 
            self.stlist.append(self.lastdraw)
        else:
            self.stlist.append(self.lastdraw)
            self.stlist.append(self.w)
    def stack_1(self):    #对于撤回功能的栈
        if self.w == None: 
            self.chosenlist.append(self.lastdraw)
        else:
            self.chosenlist.append(self.lastdraw)
            self.chosenlist.append(self.w)
    def stack_pen(self):
        self.penmarklist.append(self.penonly)
        
    def callback(self,event):
        
        #print(self.stlist)
        for i in range(5):
            self.drawpad.delete(self.stlist.pop(-i))
        

def get_pic(pic_code, pic_name):
    image = open(pic_name, 'wb')
    image.write(b64decode(pic_code))
    image.close()




def newdraw():
   
    def askcolor_1():
        
        global col_1
        quest.attributes(&quot;-topmost&quot;, False)
        col_1=askcolor(color='black', title='请选择颜色')   
        quest.attributes(&quot;-topmost&quot;, True)
       
#新建画布    
    
    def confirm_1():
        global width_b
        global height_b
        width_b = int(drawboard_w.get())
        height_b = int(drawboard_h.get())    
              
        quest.destroy()
        #画板外框宽
        wid=width_b
        hei=height_b+50
        root.state('icon')
        
        draw= Toplevel() 
        draw.geometry(&quot;%dx%d&quot; % (wid,hei))
        app = Application(master=draw)
        draw.mainloop()       
        
    def cancel_1():
        quest.destroy()
    
    quest = tk.Toplevel(root)
    quest.title('画布设置')
    quest.geometry('500x300')
    drawboard_w = tk.StringVar() 
    drawboard_w.set('1920') 
    tk.Label(quest, text='画布长度 ').place(x=20, y=20) 
    
    entry_w = tk.Entry(quest, textvariable=drawboard_w) 
    
    entry_w.place(x=130, y=20)
    
    drawboard_h = tk.StringVar() 
    drawboard_h.set('1080') 
    tk.Label(quest, text='画布高度 ').place(x=20, y=70)  
    entry_h= tk.Entry(quest, textvariable=drawboard_h)  
    entry_h.place(x=130, y=70)
    
    color_c = tk.Button(quest, text='选择画布颜色', command=askcolor_1)
    color_c.place(x=20, y=120)
    confirm = tk.Button(quest, text='新建画布', command=confirm_1)
    confirm.place(x=200,y=220)
    cancel = tk.Button(quest, text='取消', command=cancel_1)
    cancel.place(x=400,y=220)
    

#draw= Tk()
    #draw.geometry(&quot;%dx%d&quot; % (win_width, win_height))
    #app = Application(master=draw)
    #draw.mainloop()
def browser():
    
    webbrowser.open('https://drawingsword.com/post/hua-tu-ruan-jian-shi-yong-zhi-nan/')


#创建主菜单
root.title(&quot;画图（design by zhu sir）&quot;)

root.geometry(&quot;%dx%d&quot; % (win_width, win_height))


menubar = tk.Menu(root)
#新画板菜单栏
filemenu = tk.Menu(menubar,tearoff=0)
menubar.add_cascade(label='画图', menu=filemenu)
filemenu.add_command(label='新画板', command = newdraw)
filemenu.add_command(label='保存', command= None)
#设置菜单栏
settingmenu = tk.Menu(menubar, tearoff=0)
menubar.add_cascade(label='设置', menu=settingmenu)
settingmenu.add_command(label='快捷键', command = None)

#帮助菜单栏
helpmenu = tk.Menu(menubar, tearoff=0)
menubar.add_cascade(label='帮助', menu=helpmenu)
helpmenu.add_command(label=&quot;软件使用指南&quot;, command = browser)
a=random.randint(1,3)
name=&quot;bizhi&quot;+str(a)+'_gif'
filename=&quot;bizhi&quot;+str(a)+'.gif'
get_pic(eval(name), filename)
#增加背景图片

photo = tk.PhotoImage(file=filename)
theLabel = tk.Label(root,text =&quot;新建画布以开始&quot;,justify=tk.LEFT,image=photo,compound = tk.CENTER,font=(&quot;微软雅黑light&quot;,50),fg = &quot;white&quot;)

theLabel.pack()

root.config(menu=menubar)

root.mainloop()






</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法女孩]]></title>
        <id>https://tomzhu0225.github.io/post/fiction/</id>
        <link href="https://tomzhu0225.github.io/post/fiction/">
        </link>
        <updated>2021-02-18T23:35:30.000Z</updated>
        <summary type="html"><![CDATA[<p>科普小说连载中……</p>
]]></summary>
        <content type="html"><![CDATA[<p>科普小说连载中……</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://tomzhu0225.github.io/post-images/1613696987241.jpg" alt="" loading="lazy"></figure>
<p><img src="https://tomzhu0225.github.io/post-images/1615472027447.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472043737.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472049812.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472054861.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472067050.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472072546.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472078481.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472084559.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472091046.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472097450.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472112516.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472118831.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472122984.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472127664.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472132866.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472138103.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472145121.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472163911.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472173905.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472202083.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472235342.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472240775.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472245657.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472251384.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472255696.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1615472260930.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fully automatic AI player in the fps game]]></title>
        <id>https://tomzhu0225.github.io/post/fully-automatic-ai-player-in-the-fps-game/</id>
        <link href="https://tomzhu0225.github.io/post/fully-automatic-ai-player-in-the-fps-game/">
        </link>
        <updated>2021-01-11T10:39:53.000Z</updated>
        <summary type="html"><![CDATA[<p>The passage will be updated in the long run and If you have any idea or you've examined any grammar mistake in the passage, feel free to leave a comment</p>
]]></summary>
        <content type="html"><![CDATA[<p>The passage will be updated in the long run and If you have any idea or you've examined any grammar mistake in the passage, feel free to leave a comment</p>
<!-- more -->
<p><img src="https://tomzhu0225.github.io/post-images/1610525744405.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1610525751182.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1610525757579.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随机生成的噪声图像中识别特定特征（完整版）]]></title>
        <id>https://tomzhu0225.github.io/post/sui-ji-sheng-cheng-de-zao-sheng-tu-xiang-zhong-shi-bie-te-ding-te-zheng-geng-xin-ri-zhi/</id>
        <link href="https://tomzhu0225.github.io/post/sui-ji-sheng-cheng-de-zao-sheng-tu-xiang-zhong-shi-bie-te-ding-te-zheng-geng-xin-ri-zhi/">
        </link>
        <updated>2020-12-23T10:07:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><img src="https://tomzhu0225.github.io/post-images/1608718084215.png" alt="" loading="lazy"><br>
12.27<br>
进行了若干修改，增加在前面的话，增加逻辑斯蒂分类器设计；遗憾的是通过笔者的多次实验，这样的方法并不能很好的从随机矩阵中学习，来分辨特定的随机矩阵。就在刚才我想到了吴恩达教授的一句至理名言：人做不到的事情，就不要妄想机器学习和神经网络来做到！<br>
12.30<br>
大结局，编写完成求解器，在附录增加完整的代码。和大家聊一聊!<br>
<img src="https://tomzhu0225.github.io/post-images/1609331715378.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1609331727578.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本站知识共享协议（CC协议）]]></title>
        <id>https://tomzhu0225.github.io/post/ben-zhan-zhi-shi-gong-xiang-xie-yi-cc-xie-yi/</id>
        <link href="https://tomzhu0225.github.io/post/ben-zhan-zhi-shi-gong-xiang-xie-yi-cc-xie-yi/">
        </link>
        <updated>2020-12-23T10:05:43.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://tomzhu0225.github.io/post-images/1608718018397.png" alt="" loading="lazy"></figure>
<p>署名-非商业性使用-相同方式共享 4.0 国际版 (CC BY-NC-SA 4.0)</p>
<p>*这是一份非官方、未本地化的翻译文本，仅供参考。</p>
<p>这是一份易于普通人阅读与理解的许可证文本（并非法律性质的授权条款的替代内容）。</p>
<p>你可以自由地：</p>
<p>分享 – 在任何媒介或格式下再分发、传播本创作。</p>
<p>修改 – 重混、转换、依据本创作进行再创作。</p>
<p>只要遵守下述条款规定，授权人将不能撤回你使用本创作的自由。</p>
<p>唯须遵循以下条款：</p>
<p>署名 – 你必须以给予姓名标注，并提供本许可证的链接。同时你需要声明公开的创作是否经过修改。你可以采用恰当的形式将相关信息表述出来，但不得以任何形式暗示授权人已正式认可了你以及你的使用行为。</p>
<p>非商业性 – 你不得将本创作运用于商业目的。</p>
<p>相同方式共享 – 如果你对本创作进行了重混、转换、依据本创作进行再创作，你必须依据本创作采用的许可证来分发你的创作。</p>
<p>不得增加额外限制 – 你不能增设任何法律限制或是技术限制，来限制他人进行本许可证已经允许的行为。</p>
<p>声明：</p>
<p>当你使用本创作中属于公众领域的元素，或当法律有额外或限制条款允许你的使用行为时，则你不需要遵守本授权协议。</p>
<p>不提供保证。本授权协议并不能完全提供你预期需要的所有许可，例如：公共形象权，隐私权，著作人身权等其他权利，这些权利的法律限制可能会限制你使用本创作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[转子发动机建模日志！（14/12日更新）]]></title>
        <id>https://tomzhu0225.github.io/post/ji-jiang-jian-mo-wan-cheng-de-zhuan-zi-fa-dong-ji/</id>
        <link href="https://tomzhu0225.github.io/post/ji-jiang-jian-mo-wan-cheng-de-zhuan-zi-fa-dong-ji/">
        </link>
        <updated>2020-12-14T14:52:04.000Z</updated>
        <summary type="html"><![CDATA[<p>自己解决问题真的很爽！综合运用数学物理matlab以及inventor解决问题！（14/12更新）</p>
]]></summary>
        <content type="html"><![CDATA[<p>自己解决问题真的很爽！综合运用数学物理matlab以及inventor解决问题！（14/12更新）</p>
<!-- more -->
<p>2020/12/14<br>
在实际应用建模中，我们团队遇到了问题。转子发动机的转子部分是绕着一个固定的太阳轮做旋转运动，转子不但绕定子做公转，而且因两个齿轮传动比的作用，转子也自己做自转运动，这就导致转子的中心距最大的三点（转子的三个顶点）的运动包络线不是一个单纯的由圆弧和直线构成的简单图形。事实上我的小组成员在对着已有模型建模时候就出现了问题，对于已有模型的缸盖的测量太过复杂，曲率等太多根本无法有效的复原转子的缸壁形状。<br>
<img src="https://tomzhu0225.github.io/post-images/1607954973623.png" alt="" loading="lazy"><br>
在今天早晨的数学实验课上，数学老师让我们自行探索matlab软件的相关命令，而我之前因为学过一点ML课程，对matlab还算熟悉，再加上我主张个人对于编程软件的命令的态度是并不需要完全掌握，像很多知识一样，只要你知道matlab可以实现这个功能，对于其具体的实现方法你总是可以用“面向百度编程”的方法解决。我的信条是数学是为了实际应用服务的，于是在课上我想转子顶点的运动过程这个实际上我的团队面对的工程问题一定很有趣。要想研究转子顶点的轨迹那我们一定要将其进行抽象化，变成可以用数学语言描述的问题。<br>
<img src="https://tomzhu0225.github.io/post-images/1607955413379.jpg" alt="" loading="lazy"><br>
而手头的matlab软件可以可视化的，可以让我立刻了解我试想的函数（参数）方程的模样，接着我可以将函数图像，与inventor软件模拟的外形相比对（大概是一个八字形），这样我就可以验证我的模型的正确与否。而实际的验证过程并不是一番风顺的，最开始我主观的忽略了齿轮传动比的影响，认为转子自转的角度和公转的角度相等，这样的模型求出来的图像自然是不对的，具体来说是一个椭圆（而这个椭圆甚至不是对称图形）；模型出现了错误，自然需要修正模型，而另一个问题出现了，对于一个没有学习过机械原理的大一学生来讲，我该如何知道一个转动比为1.5的行星齿轮组，各自旋转的比例呢？他们各自自转的角度的比例是3：2吗？我重新计算，但是函数输出仍然和真实模型相差甚远。（甚至于我也并不清楚传动比是什么概念，仅仅传动比就决定了两个齿轮各自旋转的角度了吗，那圆心距，两个齿轮直径呢？）我退而求其次观察inventor中已经建模好的模型<br>
<img src="https://tomzhu0225.github.io/post-images/1607956096993.png" alt="" loading="lazy"><br>
模型中我已经进行了约束，而我完全可以观察在inventor仿真中两个齿轮的各自旋转的比例。我观察到旋转的比例大概是1：3（当两个齿轮的接触点旋转theta时，转子自转1/3*theta）。接下来就是验证，我在matlab里输入再次计算的结果<br>
<img src="https://tomzhu0225.github.io/post-images/1607956489068.png" alt="" loading="lazy"><br>
图形奇迹般的和真实情况吻合。但是如何将这个函数输入到inventor的草图中来进行拉伸建模进而和已知模型对比来进一步确认真实性呢？这时候我的脑子里其实已经有了两种预案，首先如果inventor中有直接输入函数的功能那就很方便，如若没有或许我们就得把函数分成多个数据点来输入inventor,用小直线段来近似曲线。经过我的一番搜索，inventor在2013年加入了函数草图的功能，这样我就可以直接输入函数了！<br>
<img src="https://tomzhu0225.github.io/post-images/1607956812477.png" alt="" loading="lazy"><br>
有意思的一点是我们设计参照的原模型似乎就是在2013之前建模完成的，作者使用的就是细分为直线段建的模！这样导致缸体内壁并不平整，在之前我对已有模型做力学仿真的时候做的极不顺利，仿真根本没法进行下去。而新方法在力学仿真里效果如何还得之后去验证。<br>
<strong>写这些不是为了炫耀我的思想多么严谨，而是我认为这种研究问题的方法是很有价值的，在这个新的时代人早就不能穷尽所有知识了，我们做的是在自己已有知识的基础上，充分利用外界的软件，互联网，自己直觉上的猜想，来验证自己想要解决的问题。我们站在巨人的肩膀上！</strong></p>
<hr>
<p>2020/12/6<br>
<img src="https://tomzhu0225.github.io/post-images/1607257937625.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1607436979090.png" alt="" loading="lazy"><br>
<img src="https://tomzhu0225.github.io/post-images/1607436989608.png" alt="" loading="lazy"></p>
<p>怎么说转子发动机一直是我的梦想吧，毕竟弱者打败强者的故事不论何时都不过时，马自达在1991年的勒芒比赛中Mazda 787B 凭借着转子发动机赢得了勒芒比赛的总冠军，成为历史上唯一夺得过勒芒24小时耐力赛总冠军的亚洲厂商，以至于第二年国际汽联不惜动用手段禁止转子发动机参赛！这种凭借着个人能力而让规则不惜做出改变也要扼杀的，是多么的年少轻狂。多年以来纵然转子发动机有诸多缺陷，马自达从未停止改良她的脚步，在其他技术领域马自达也总是最另类的那一批：创驰蓝天，均质压燃......电动机当道，纵然知道最终要消亡，汽油机总要发出最后的一声低吼，压榨出最后一丝潜力，让世人知道汽油机永不为奴！卖车挣钱，花钱搞转子，没钱再卖车，马自达的工程师和高层一定有发自内心的热爱！时间不多，我先写这么多，思绪甚是杂乱，来日再梳理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站使用指南（评论系统开启！）]]></title>
        <id>https://tomzhu0225.github.io/post/ping-lun-xi-tong-kai-qi/</id>
        <link href="https://tomzhu0225.github.io/post/ping-lun-xi-tong-kai-qi/">
        </link>
        <updated>2020-12-09T08:18:58.000Z</updated>
        <summary type="html"><![CDATA[<p>大家评论要遵守社会主义价值规范哦</p>
]]></summary>
        <content type="html"><![CDATA[<p>大家评论要遵守社会主义价值规范哦</p>
<!-- more -->
<p>一. 界面功能</p>
<p>在网页版的页面的右上角，或者手机版的下拉菜单中会找到3枚菜单：首页、归档、标签。<br>
首页按钮会带你来到主界面，其中展示的文章是按照时间发布顺序排序的。<br>
归档按钮会来到一个页面展示了文章的初始发布时间线。<br>
标签按钮会出现几个标签，文章大多数按照标签所示分类，可以按需引索。<br>
同时网站本身也带有文章的关键字的搜索功能。</p>
<h2 id="关于按钮">关于按钮</h2>
<p>第一次入站请一定要看关于！</p>
<p>二. 评论功能</p>
<p>每篇文章都有评论功能，请善用这个功能。互联网非法外之地。<br>
在评论时请填写自己的昵称（我的老熟人就用一个我能认出来的昵称吧），邮箱。</p>
<p>三. 文章加载</p>
<p>请尽量不要用手机中的微信或者qq自带浏览器打开这个网页，而应使用独立浏览器打开。要得到最佳的使用体验请用电脑浏览。因为网站使用的是境外服务器一些带有图片的文章可能加载较慢，请坐和放宽耐心等待。</p>
<p>四. 写作</p>
<p>文章都使用markdown语法写作，但是我目前并没有学习markdown语法，所以文章版面朴实无华，这一点会在日后改变。数学类的文章我用latex写作，但是不知道是否可以将tex文件直接上传进行编译，所以暂时的解决办法是转换成图片上传（加载较慢）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以惯性约束聚变为推进方式的深空殖民探索方案]]></title>
        <id>https://tomzhu0225.github.io/post/yi-guan-xing-yue-shu-ju-bian-wei-tui-jin-fang-shi-de-shen-kong-zhi-min-tan-suo-fang-an/</id>
        <link href="https://tomzhu0225.github.io/post/yi-guan-xing-yue-shu-ju-bian-wei-tui-jin-fang-shi-de-shen-kong-zhi-min-tan-suo-fang-an/">
        </link>
        <updated>2020-12-07T07:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>因为是结课作业也别想什么严谨了，大家看个乐呵就行。<br>
<img src="https://tomzhu0225.github.io/post-images/1607325830431.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>